class Node:

    def __init__(self, symbol, child1, child2 = None):
        self.symbol = symbol
        self.child1 = child1
        self.child2 = child2

    def __repr__(self):

        return self.symbol



def convert_grammar(grammar_file):
    RULE_DICT = {}
    unit_productions, result = [], []
    res_append = result.append
    index = 0

    with open(grammar_file,"r", encoding="utf-8") as cfg:
        lines = cfg.readlines()


    grammar = [x.replace("->", "").split() for x in lines]

    for rule in grammar:
        new_rules = []
        if len(rule) == 2 and rule[1][0] != "'":
            # Rule is in form A -> X, so back it up for later and continue with the next rule.
            unit_productions.append(rule)
            if rule[0] not in RULE_DICT:
                RULE_DICT[rule[0]] = []
            RULE_DICT[rule[0]].append(rule[1:])
            continue
        elif len(rule) > 2:
            # Rule is in form A -> X B C or A -> X a.
            terminals = [(item, i) for i, item in enumerate(rule) if item[0] == "'"]
            #print(terminals)
            if terminals:
                for item in terminals:
                    # Create a new non terminal symbol and replace the terminal symbol with it.
                    # The non terminal symbol derives the replaced terminal symbol.
                    rule[item[1]] = f"{rule[0]}{str(index)}"
                    new_rules += [f"{rule[0]}{str(index)}", item[0]]
                index += 1
            while len(rule) > 3:
                new_rules += [f"{rule[0]}{str(index)}", rule[1], rule[2]]
                rule = [rule[0]] + [f"{rule[0]}{str(index)}"] + rule[3:]
                index += 1
        # Adds the modified or unmodified (in case of A -> x i.e.) rules.
        if rule[0] not in RULE_DICT:
            RULE_DICT[rule[0]] = []
        RULE_DICT[rule[0]].append(rule[1:])
        #print(rule[1:])
        res_append(rule)
        if new_rules:
            res_append(new_rules)
    # Handle the unit productions (A -> X)
    while unit_productions:
        rule = unit_productions.pop()
        if rule[1] in RULE_DICT:
            for item in RULE_DICT[rule[1]]:
                new_rule = [rule[0]] + item
                if len(new_rule) > 2 or new_rule[1][0] == "'":
                    res_append(new_rule)
                else:
                    unit_productions.append(new_rule)
                if rule[0] not in RULE_DICT:
                    RULE_DICT[rule[0]] = []
                RULE_DICT[rule[0]].append(rule[1:])
    return result

def parse(grammar, sentence):

        length = len(sentence.split())
        # self.parse_table[y][x] is the list of nodes in the x+1 cell of y+1 row in the table.
        # That cell covers the word below it and y more words after.
        parse_table = [[[] for x in range(length - y)] for y in range(length)]

        for i, word in enumerate(sentence.split()):
            # Find out which non terminals can generate the terminals in the input string
            # and put them into the parse table. One terminal could be generated by multiple
            # non terminals, therefore the parse table will contain a list of non terminals.
            for rule in grammar:
                #print(rule)
                if f"'{word}'" == rule[1]:
                    parse_table[0][i].append(Node(rule[0], word))
        for words_to_consider in range(2, length + 1):
            for starting_cell in range(0, length - words_to_consider + 1):
                for left_size in range(1, words_to_consider):
                    right_size = words_to_consider - left_size

                    left_cell = parse_table[left_size - 1][starting_cell]
                    right_cell = parse_table[right_size - 1][starting_cell + left_size]

                    for rule in grammar:
                        #print(rule)
                        left_nodes = [n for n in left_cell if n.symbol == rule[1]]

                        if left_nodes:
                            #print(left_nodes)
                            right_nodes = [n for n in right_cell if n.symbol == rule[2]]
                            parse_table[words_to_consider - 1][starting_cell].extend(
                                [Node(rule[0], left, right) for left in left_nodes for right in right_nodes]
                            )

        return parse_table


def print_tree(parse_table):

        start_symbol = "S"

        print(parse_table)

        final_nodes = [n for n in parse_table[-1][0] if n.symbol == start_symbol]
        if final_nodes:

            trees = [generate_tree(node) for node in final_nodes]
            for tree in trees:
                    print(tree)

            return trees
        else:
            print("The given sentence is not contained in the language produced by the given "
                  "grammar!")


def generate_tree(node):

    if node.child2 == None:
        return f"[{node.symbol} '{node.child1}']"
    else:
        return f"[{node.symbol} {generate_tree(node.child1)} {generate_tree(node.child2)}]"


grammar = convert_grammar("grammar_v4.txt")
print("bu akşamki toplantıya katılacak mısınız")
parse_table = parse(grammar, "bu akşamki toplantıya katılacak mısınız")
print_tree(parse_table)